
// THIS CODE IS GENERATED BY THE META PIPELINE
#pragma once

{% for include in includes %}
#include "{{ include }}"
{% endfor %}

#include "service/logical_thread.hpp"
#include "service/sender.hpp"

#include "service/protocol/header.hpp"
#include "service/protocol/serialization.hpp"

#include "common/assert_verify.hpp"
#include "common/disable_special_members.hpp"

{% for interface in interfaces %}
{% for namespace in interface.namespaces %} 
{%if loop.is_first %}namespace {{namespace}}{%else%}::{{namespace}}{%endif%}
{% endfor %}

{
    // Interface {{ interface.full_type_name }}
    class {{ interface.type_name }}_IPC : public mega::service::Proxy< {{ interface.type_name }} >
    {
        service::Sender& m_sender;
        using Buffer = std::vector< char >;
    public:
        inline {{ interface.type_name }}_IPC(service::Access& access,
                service::Sender& sender,
                const service::MPTFO& mptfo,
                const service::RTTI& rtti )
        :   service::Proxy< {{ interface.type_name }} >(access, mptfo, rtti)
        ,   m_sender(sender)
        {
        }

{% for function in interface.functions %}
        virtual {{ function.return_type }} {{ function.name }}
        (
{% for param in function.parameters %}
            {{ param.type}} {{ param.name }}{% if not loop.is_last %},{% endif %}
{% endfor %}
        ) override
        {
            service::OArchive oa( m_access );

            using namespace std::string_literals;

            auto& thisLogicalThread = service::LogicalThread::get();

            const auto thisMPTF = thisLogicalThread.getMPTF();
            const auto messageID = thisLogicalThread.getUniqueMessageID();
            auto stack = thisLogicalThread.top();
            stack.push_back( thisMPTF );

            const service::Header header
            {
                stack,
                messageID,
                thisMPTF,
                m_mptfo,
                "{{ interface.full_type_name }}"s,
                "{{ function.name }}"s
            };

            oa << service::MessageType::eRequest;
            oa << header;

{% for param in function.parameters %}
            oa << {{ param.name }};
{% endfor %}

{% if function.return_type != "void" %}
            {{ function.return_type }} result{};
{% endif %}

            bool bResponse = false;

            thisLogicalThread.setInterProcessResponseCallback(
                messageID,
                [   
                    &access = m_access,
                    &bResponse
                   {%if function.return_type != "void" %},&result{% endif %}
                ]
                (const service::InterProcessResponse& interProcessResponse)
                {
{% if function.return_type != "void" %}
                    service::MessageType messageType;
                    service::Header header;
                    service::IArchive ia(access, interProcessResponse.m_buffer);
                    ia >> messageType;
                    ia >> header;
                    ia >> result;
{% endif %}
                    bResponse = true;
                });

            m_sender.send( oa.vector() );

            while(bResponse == false)
            {
                thisLogicalThread.receive();
            }

{% if function.return_type != "void" %}
            return result;
{% endif %}
        }
{% endfor %}
    };
}
{% endfor %}

