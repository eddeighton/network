
// THIS CODE IS GENERATED BY THE META PIPELINE
#pragma once

{% for include in includes %}
#include "{{ include }}"
{% endfor %}


#include "service/logical_thread.hpp"
#include "service/connection.hpp"

#include "service/protocol/header.hpp"
#include "service/protocol/serialization.hpp"


#include "common/assert_verify.hpp"
#include "common/disable_special_members.hpp"
#include "common/log.hpp"
#include "common/time.hpp"

// using namespace std::string_literals;
// #define LOG_PROXY_IPC(msg) LOG("PROXY_IPC: "s + msg)
#define LOG_PROXY_IPC(msg) 

namespace mega::service::detail
{
    template < typename T, typename Archive >
    void serialize( std::weak_ptr< Proxy< T > >&,  Archive& );
}

{% for interface in interfaces %}

namespace mega::service::detail
{
    // ensure serialization templates are instantiated
    template<>
    void serialize< {{ interface.full_type_name }}, mega::service::IArchive >(
        std::weak_ptr< Proxy< {{ interface.full_type_name }} > >& , IArchive& ); 

    template<>
    void serialize< {{ interface.full_type_name }}, mega::service::OArchive >(
        std::weak_ptr< Proxy< {{ interface.full_type_name }} > >& , OArchive& );
}

{% for namespace in interface.namespaces %} 
{%if loop.is_first %}namespace {{namespace}}{%else%}::{{namespace}}{%endif%}
{% endfor %}

{

    // Interface {{ interface.full_type_name }}
    class {{ interface.type_name }}_IPC : public mega::service::Proxy< {{ interface.type_name }} >
    {
        service::Connection::WeakPtr m_pConnection;
        using Buffer = std::vector< char >;
    public:
        inline {{ interface.type_name }}_IPC(service::Access& access,
                service::Connection::WeakPtr& pConnection,
                const service::MPTFO& mptfo,
                const service::RTTI& rtti )
        :   service::Proxy< {{ interface.type_name }} >(access, mptfo, rtti)
        ,   m_pConnection(pConnection)
        {
        }

{% for function in interface.functions %}
        virtual {{ function.return_type }} {{ function.name }}
        (
{% for param in function.parameters %}
            {{ param.type}} {{ param.name }}{% if not loop.is_last %},{% endif %}
{% endfor %}

        ) override
        {
            LOG_PROXY_IPC( "Started {{ interface.full_type_name }}::{{ function.name }}" );
            service::OArchive oa( m_access );

            using namespace std::string_literals;

            auto& thisLogicalThread = service::LogicalThread::get();

            const auto thisMPTF = thisLogicalThread.getMPTF();
            const auto messageID = thisLogicalThread.getUniqueMessageID();
            auto stack = thisLogicalThread.top();
            stack.push_back( thisMPTF );

            const service::Header header
            {
                stack,
                messageID,
                thisMPTF,
                m_mptfo,
                "{{ interface.full_type_name }}"s,
                "{{ function.name }}"s
            };

            oa << service::MessageType::eRequest;
            oa << header;
{% for param in function.parameters %}
            oa << {{ param.name }};
{% endfor %}

{% if function.return_type != "void" %}
            {{ function.return_type }} result{};
{% endif %}

            bool bResponse = false;

            LOG_PROXY_IPC( "Registering callback {{ interface.full_type_name }}::{{ function.name }}" );
            thisLogicalThread.setInterProcessResponseCallback(
                messageID,
                [
                    &access = m_access
                   ,&bResponse
                   {%if function.return_type != "void" %},&result{% endif %}

                ]
                (const service::InterProcessResponse& interProcessResponse)
                {
{% if function.return_type != "void" %}
                    service::MessageType messageType;
                    service::Header header;
                    service::IArchive ia(access, interProcessResponse.m_buffer);
                    ia >> messageType;
                    ia >> header;
                    ia >> result;
{% endif %}
                    bResponse = true;
                });

            auto startTime = std::chrono::steady_clock::now();

            LOG_PROXY_IPC( "Sending {{ interface.full_type_name }}::{{ function.name }}" );
            {
                if( auto p = m_pConnection.lock() )
                {
                    p->send( oa.vector());
                }
                else
                {
                    LOG_PROXY_IPC( "Connection error {{ interface.full_type_name }}::{{ function.name }}" );
                    THROW_RTE( "Unable to get connection" );
                }
            }

            LOG_PROXY_IPC( "Waiting {{ interface.full_type_name }}::{{ function.name }}" );
            while(bResponse == false)
            {
                thisLogicalThread.receive();
            }

            LOG_PROXY_IPC( "Completed {{ interface.full_type_name }}::{{ function.name }}" );

            LOG( "{{ interface.full_type_name }}::{{ function.name }} : " << 
                common::printDuration( common::elapsed( startTime ) ) );

{% if function.return_type != "void" %}
            return result;
{% endif %}
        }
{% endfor %}
    };
}
{% endfor %}

