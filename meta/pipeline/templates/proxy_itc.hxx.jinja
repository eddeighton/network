
// THIS CODE IS GENERATED BY THE META PIPELINE
#pragma once

{% for include in includes %}
#include "{{ include }}"
{% endfor %}

#include "service/logical_thread.hpp"
#include "service/sender.hpp"

#include "service/protocol/header.hpp"

#include "common/assert_verify.hpp"
#include "common/disable_special_members.hpp"
#include "common/serialisation.hpp"

#include <boost/interprocess/interprocess_fwd.hpp>
#include <boost/interprocess/streams/vectorstream.hpp>

#include <boost/archive/binary_iarchive.hpp>
#include <boost/archive/binary_oarchive.hpp>

{% for interface in interfaces %}
{% for namespace in interface.namespaces %} 
{%if loop.is_first %}namespace {{namespace}}{%else%}::{{namespace}}{%endif%}
{% endfor %}

{
    // Interface {{ interface.full_type_name }}
    class {{ interface.type_name }}_ITC : public mega::service::Proxy< {{ interface.type_name }} >
    {
        {{ interface.type_name }}* m_ptr;
        service::LogicalThread& m_logicalThread;
    public:
        inline {{ interface.type_name }}_ITC({{ interface.type_name }}* ptr,
                service::LogicalThread& logicalThread,
                service::MPTFO mptfo, const service::RTTI& rtti )
        :   service::Proxy< {{ interface.type_name }} >( mptfo, rtti )
        ,   m_ptr(ptr)
        ,   m_logicalThread(logicalThread)
        {
        }

{% for function in interface.functions %}
        virtual {{ function.return_type }} {{ function.name }}
        (
{% for param in function.parameters %}
            {{ param.type}} {{ param.name }}{% if not loop.is_last %},{% endif %}
{% endfor %}
        ) override
        {
            auto& thisLogicalThread = service::LogicalThread::get();
            if( m_logicalThread.getMPTF() == thisLogicalThread.getMPTF() )
            {
                // same fiber - do direct function call
                return m_ptr->{{ function.name }}
                (
{% for param in function.parameters %}
                    {{ param.name }}{% if not loop.is_last %},{% endif %}
{% endfor %}
                );
            }
            else
            {
                bool bResponse = false;
{% if function.return_type != "void" %}
                {{ function.return_type }} result{};
                service::Functor call = 
                    [ ptr = m_ptr, &thisLogicalThread, &result, &bResponse ]() -> void
{% else %}
                service::Functor call = 
                    [ ptr = m_ptr, &thisLogicalThread, &bResponse ]() -> void
{% endif %}
                {
                     try
                     {
{% if function.return_type != "void" %}
                         result =
{% endif %}
                         ptr->{{ function.name }}
                         (
{% for param in function.parameters %}
                            {{ param.name }}{% if not loop.is_last %},{% endif %}
{% endfor %}
                         );
                         thisLogicalThread.send
                         (
                            service::InProcessResponse
                            { [&bResponse]() { bResponse = true; } }
                         );
                     }
                     catch(...)
                     {
                         thisLogicalThread.send
                         (
                             service::InProcessResponse
                             {
                                [pException = std::current_exception()]()
                                { std::rethrow_exception(pException); }
                             }
                         );
                     }
                };
                m_logicalThread.send(service::InProcessRequest{std::move(call)});

                while(bResponse == false)
                {
                    thisLogicalThread.receive();
                }

{% if function.return_type != "void" %}
                return result;
{% endif %}
            }
        }

{% endfor %}
    };
}
{% endfor %}

