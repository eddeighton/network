
// THIS CODE IS GENERATED BY THE META PIPELINE
#pragma once

#include "service/gen/proxy_itc.hxx"
#include "service/gen/proxy_ipc.hxx"

{% for include in includes %}
#include "{{ include }}"
{% endfor %}

namespace mega::service
{
    using ProxyVariant = std::variant
    <
{% for interface in interfaces %}
        std::unique_ptr< {% for namespace in interface.namespaces %}::{{namespace}}{% endfor %}::{{ interface.type_name }}_ITC >,
        std::unique_ptr< {% for namespace in interface.namespaces %}::{{namespace}}{% endfor %}::{{ interface.type_name }}_IPC >{%if not loop.is_last%},{% endif %}

{% endfor %}
    >;
    using ProxyVariantVector = std::vector< ProxyVariant >;
    using InterfaceMPTFO    = std::pair< InterfaceTypeName, MPTFO >;
    using InterfaceMPTFOMap = std::map< InterfaceMPTFO, Interface* >;

    template< typename TInterface, typename TProxy >
    void registerIfInterface(Sender& sender, const Registration::Registrant& registrant,
            ProxyVariantVector& proxies, InterfaceMPTFOMap& interfaceMPTFOMap)
    {
        const auto interfaceTypeName = getInterfaceTypeName< TInterface >();
        if(registrant.m_rtti.contains(interfaceTypeName))
        {
            const auto key = InterfaceMPTFO{interfaceTypeName, registrant.m_mptfo};
            if(interfaceMPTFOMap.find(key) == interfaceMPTFOMap.end())
            {
                auto pProxy = std::make_unique<TProxy>(sender, registrant.m_mptfo, registrant.m_rtti);
                interfaceMPTFOMap.insert(std::make_pair(key, pProxy.get()));
                proxies.push_back(std::move(pProxy));
            }
        }
    }

    template< typename TInterface >
    void conditionallyAddRTTI(Interface* pInterface, RTTI& rtti)
    {
        if(dynamic_cast< TInterface* >( pInterface ))
        {
            rtti.m_interfaces.push_back(getInterfaceTypeName< TInterface >());
        }
    }

    template< typename TInterface, typename TProxy >
    void registerIfInterface(Interface* pInterface, MPTFO mptfo, const RTTI& rtti,
            ProxyVariantVector& proxies, InterfaceMPTFOMap& interfaceMPTFOMap)
    {
        if(auto p = dynamic_cast< TInterface* >( pInterface ))
        {
            auto pProxy = std::make_unique< TProxy >(p, LogicalThread::get(), mptfo, rtti);
            const auto interfaceTypeName = getInterfaceTypeName< TInterface >();
            interfaceMPTFOMap.insert(
                std::make_pair( InterfaceMPTFO{ interfaceTypeName, mptfo }, pProxy.get() ) );
            proxies.push_back( std::move( pProxy ) );
        }
    }

    inline void registerInProcessProxy(Interface& object, const MPTFO mptfo,
            ProxyVariantVector& proxies, InterfaceMPTFOMap& interfaceMPTFOMap )
    {
        RTTI rtti;

{% for interface in interfaces %}
        conditionallyAddRTTI< {% for namespace in interface.namespaces %}::{{namespace}}{% endfor %}::{{ interface.type_name }} >( &object, rtti );
        registerIfInterface< {% for namespace in interface.namespaces %}::{{namespace}}{% endfor %}::{{ interface.type_name }}, {% for namespace in interface.namespaces %}::{{namespace}}{% endfor %}::{{ interface.type_name }}_ITC >( &object, mptfo, rtti, proxies, interfaceMPTFOMap );

{% endfor %}
    }

    inline void update(Sender& sender, const Registration& registration, ProxyVariantVector& proxies, InterfaceMPTFOMap& interfaceMPTFOMap)
    {
        for( const auto& registrant : registration.m_registrants )
        {
{% for interface in interfaces %}
            // registerInProcessProxy< {% for namespace in interface.namespaces %}::{{namespace}}{% endfor %}::{{ interface.type_name }}, {% for namespace in interface.namespaces %}::{{namespace}}{% endfor %}::{{ interface.type_name }}_ITC >(sender, registrant, proxies, interfaceMPTFOMap);
            registerIfInterface< {% for namespace in interface.namespaces %}::{{namespace}}{% endfor %}::{{ interface.type_name }}, {% for namespace in interface.namespaces %}::{{namespace}}{% endfor %}::{{ interface.type_name }}_IPC >(sender, registrant, proxies, interfaceMPTFOMap);

{% endfor %}
        }
    }
}

