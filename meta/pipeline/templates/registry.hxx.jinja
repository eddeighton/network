
// THIS CODE IS GENERATED BY THE META PIPELINE
#pragma once

#include "service/gen/proxy_itc.hxx"
#include "service/gen/proxy_ipc.hxx"

{% for include in includes %}
#include "{{ include }}"
{% endfor %}

namespace mega::service
{
    class Access;

    using ProxyVariant = std::variant
    <
{% for interface in interfaces %}
        std::shared_ptr< {% for namespace in interface.namespaces %}::{{namespace}}{% endfor %}::{{ interface.type_name }}_ITC >,
        std::shared_ptr< {% for namespace in interface.namespaces %}::{{namespace}}{% endfor %}::{{ interface.type_name }}_IPC >{%if not loop.is_last%},{% endif %}

{% endfor %}
    >;
    using ProxyVariantVector = std::vector< ProxyVariant >;
    using InterfaceMPTFO     = std::pair< InterfaceTypeName, MPTFO >;
    using InterfaceMPTFOMap  = std::map< InterfaceMPTFO, std::shared_ptr<Interface> >;

    template< typename TInterface, typename TProxy >
    void registerIfInterface(Access& access, Sender& sender, const Registration::Registrant& registrant,
            ProxyVariantVector& proxies, InterfaceMPTFOMap& interfaceMPTFOMap)
    {
        const auto interfaceTypeName = getInterfaceTypeName< TInterface >();
        if(registrant.m_rtti.contains(interfaceTypeName))
        {
            const auto key = InterfaceMPTFO{interfaceTypeName, registrant.m_mptfo};
            if(interfaceMPTFOMap.find(key) == interfaceMPTFOMap.end())
            {
                auto pProxy = std::make_shared<TProxy>(
                    access, sender, registrant.m_mptfo, registrant.m_rtti);
                interfaceMPTFOMap.insert(std::make_pair(key, pProxy));
                proxies.push_back(std::move(pProxy));
            }
        }
    }

    inline void update(Access& access, Sender& sender, const Registration& registration,
        ProxyVariantVector& proxies, InterfaceMPTFOMap& interfaceMPTFOMap)
    {
        for( const auto& registrant : registration.m_registrants )
        {
{% for interface in interfaces %}
            registerIfInterface< {% for namespace in interface.namespaces %}::{{namespace}}{% endfor %}::{{ interface.type_name }}, {% for namespace in interface.namespaces %}::{{namespace}}{% endfor %}::{{ interface.type_name }}_IPC >(
                access, sender, registrant, proxies, interfaceMPTFOMap);
{% endfor %}

        }
    }

    template< typename TInterface >
    void conditionallyAddRTTI(Interface* pInterface, RTTI& rtti)
    {
        if(dynamic_cast< TInterface* >( pInterface ))
        {
            rtti.m_interfaces.push_back(getInterfaceTypeName< TInterface >());
        }
    }

    template< typename TInterface, typename TProxy >
    void registerIfInterface(Access& access, Interface* pInterface, MPTFO mptfo, const RTTI& rtti,
            ProxyVariantVector& proxies, InterfaceMPTFOMap& interfaceMPTFOMap)
    {
        if(auto p = dynamic_cast< TInterface* >( pInterface ))
        {
            auto pProxy = std::make_shared< TProxy >(access, p, LogicalThread::get(), mptfo, rtti);
            const auto interfaceTypeName = getInterfaceTypeName< TInterface >();
            interfaceMPTFOMap.insert(
                std::make_pair( InterfaceMPTFO{ interfaceTypeName, mptfo }, pProxy ) );
            proxies.push_back( std::move( pProxy ) );
        }
    }

    inline void registerInProcessProxy(Access& access, Interface& object, const MPTFO mptfo,
            ProxyVariantVector& proxies, InterfaceMPTFOMap& interfaceMPTFOMap )
    {
        RTTI rtti;

{% for interface in interfaces %}
        conditionallyAddRTTI< {% for namespace in interface.namespaces %}::{{namespace}}{% endfor %}::{{ interface.type_name }} >( &object, rtti );
{% endfor %}
{% for interface in interfaces %}
        registerIfInterface< {% for namespace in interface.namespaces %}::{{namespace}}{% endfor %}::{{ interface.type_name }}, {% for namespace in interface.namespaces %}::{{namespace}}{% endfor %}::{{ interface.type_name }}_ITC >(
            access, &object, mptfo, rtti, proxies, interfaceMPTFOMap );
{% endfor %}
    }
}

