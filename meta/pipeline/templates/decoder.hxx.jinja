
#pragma once

#include "service/logical_thread.hpp"
#include "service/protocol/serialization.hpp"
#include "service/sender_socket.hpp"
#include "service/registry.hpp"
#include "service/connection.hpp"

{% for include in includes %}
#include "{{ include }}"
{% endfor %}

namespace mega::service
{

void decodeInboundRequest(boost::archive::binary_iarchive& ia, const Header& header,
        Connection::WeakPtr pResponseConnection)
{
    using namespace std::string_literals;

    auto& logicalThread = mega::service::Registry::getReadAccess()
        ->getLogicalThread(header.m_responder.getMPTF());

    // request or response
    logicalThread.send(
        mega::service::InterProcessRequest
        {
            [&pResponseConnection, header]()
            {
                if( header.m_interfaceName.empty() )
                {
                    THROW_RTE( "Missing interface name in request: " << header );
                }
{% for interface in interfaces %}
                else if( header.m_interfaceName.str() == "{{ interface.full_type_name }}" )
                {
                    auto p = mega::service::Registry::getReadAccess()
                        ->one<{{ interface.full_type_name }}>(header.m_responder);
                    if( header.m_functionName.empty() )
                    {
                        THROW_RTE( "Missing function name in request: " << header );
                    }
{% for function in interface.functions %}
                    else if( header.m_functionName.str() == "{{ function.name }}" )
                    {
                        try
                        {
                            {
                                service::LogicalThread::StackEntry s( service::LogicalThread::get(), header.m_stack );
{% if function.return_type != "void" %}
                                {{function.return_type}} result =
{% endif %}
                                p->{{ function.name }}
                                (
{% for param in function.parameters %}
                                    {{ param.name }}{% if not loop.is_last %},{% endif %}
{% endfor %}
                                );

                                boost::interprocess::basic_vectorbuf< mega::service::PacketBuffer > vectorBuffer;
                                boost::archive::binary_oarchive oa(vectorBuffer, service::boostArchiveFlags);

                                oa << mega::service::MessageType::eResponse;
                                oa << header;
{% if function.return_type != "void" %}
                                oa << result;
{% endif %}
                                pResponseConnection.lock()->getSender().send(vectorBuffer.vector());
                                // std::cout << "Response to request sent" << std::endl;
                            }
                        }
                        catch(...)
                        {
                            // TODO: ??
                            throw;
                        }
                    }
{% endfor %}
                }
{% endfor %}
            }
        }
    );
}
}

